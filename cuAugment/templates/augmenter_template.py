# The MIT License (MIT)

# Copyright (c) 2020 NVIDIA CORPORATION.

# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

payload = \
'''
# The MIT License (MIT)

# Copyright (c) {{year}}, NVIDIA CORPORATION.

# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# NOTE: this file was generated by a machine 

from numba import cuda
import math

@cuda.jit
def augment(batch_in, batch_out, empty_values{% for op, param, params in spatial_ops: %}{% if op.has_params(): %}, {{params}}{% endif %}{% endfor %}{% for op, param, params in color_ops: %}{% if op.has_params(): %}, {{params}}{% endif %}{% endfor %}):
    """fused augmentation kernel for SOL tensor manipulation"""

    {% if channel_mode == 'CF2CF' or channel_mode == 'CF2CL': %}
    # fix the dimensions of the input tensor in "channels first" order
    dimB_in = 0
    dimC_in = 1
    {% if dim > 0: %}
    dimX_in = 2
    {% endif %}
    {% if dim > 1: %}
    dimY_in = 3
    {% endif %}
    {% if dim > 2: %}
    dimZ_in = 4
    {% endif %}
    {% if dim > 3: %}
    dimT_in = 5
    {% endif %}
    {% endif %}
    {% if channel_mode == 'CL2CL' or channel_mode == 'CL2CF': %}
    # fix the dimensions of the input tensor in "channels last" order
    dimB_in = 0
    dimC_in = {{dim+1}}
    {% if dim > 0: %}
    dimX_in = 1
    {% endif %}
    {% if dim > 1: %}
    dimY_in = 2
    {% endif %}
    {% if dim > 2: %}
    dimZ_in = 3
    {% endif %}
    {% if dim > 3: %}
    dimT_in = 4
    {% endif %}
    {% endif %}

    {% if channel_mode == 'CF2CF' or channel_mode == 'CL2CF': %}
    # fix the dimensions of the output tensor in "channels first" order
    dimB_out = 0
    dimC_out = 1
    {% if dim > 0: %}
    dimX_out = 2
    {% endif %}
    {% if dim > 1: %}
    dimY_out = 3
    {% endif %}
    {% if dim > 2: %}
    dimZ_out = 4
    {% endif %}
    {% if dim > 3: %}
    dimT_out = 5
    {% endif %}
    {% endif %}
    {% if channel_mode == 'CL2CL' or channel_mode == 'CF2CL': %}
    # fix the dimensions of the output tensor in "channels last" order
    dimB_out = 0
    dimC_out = {{dim+1}}
    {% if dim > 0: %}
    dimX_out = 1
    {% endif %}
    {% if dim > 1: %}
    dimY_out = 2
    {% endif %}
    {% if dim > 2: %}
    dimZ_out = 3
    {% endif %}
    {% if dim > 3: %}
    dimT_out = 4
    {% endif %}
    {% endif %}

    # set starting indices of grid-stride loops    
    lowerB = 0 
    lowerC = 0
    {% if dim == 1: %}
    lowerX = cuda.blockIdx.x*cuda.blockDim.x+cuda.threadIdx.x
    {% endif %}
    {% if dim == 2: %}
    lowerX = cuda.blockIdx.y*cuda.blockDim.y+cuda.threadIdx.y
    lowerY = cuda.blockIdx.x*cuda.blockDim.x+cuda.threadIdx.x
    {% endif %}
    {% if dim == 3: %}
    lowerX = cuda.blockIdx.z*cuda.blockDim.z+cuda.threadIdx.z
    lowerY = cuda.blockIdx.y*cuda.blockDim.y+cuda.threadIdx.y
    lowerZ = cuda.blockIdx.x*cuda.blockDim.x+cuda.threadIdx.x
    {% endif %}
    {% if dim == 4: %}
    lowerX = 0
    lowerY = cuda.blockIdx.z*cuda.blockDim.z+cuda.threadIdx.z
    lowerZ = cuda.blockIdx.y*cuda.blockDim.y+cuda.threadIdx.y
    lowerT = cuda.blockIdx.x*cuda.blockDim.x+cuda.threadIdx.x
    {% endif %}
    
    # set strides of grid-stride loops
    strideB = 1 
    strideC = 1
    {% if dim == 1: %}
    strideX = cuda.blockDim.x*cuda.gridDim.x
    {% endif %}
    {% if dim == 2: %}
    strideX = cuda.blockDim.y*cuda.gridDim.y
    strideY = cuda.blockDim.x*cuda.gridDim.x
    {% endif %}
    {% if dim == 3: %}
    strideX = cuda.blockDim.z*cuda.gridDim.z
    strideY = cuda.blockDim.y*cuda.gridDim.y
    strideZ = cuda.blockDim.x*cuda.gridDim.x
    {% endif %}
    {% if dim == 4: %}
    strideX = 1
    strideY = cuda.blockDim.z*cuda.gridDim.z
    strideZ = cuda.blockDim.y*cuda.gridDim.y
    strideT = cuda.blockDim.x*cuda.gridDim.x
    {% endif %}

    # 2+{{dim}} nested grid-stride loops follow (ignore strange indentation)
    # for all batch indices in the output tensor    
    for b_out in range(lowerB, batch_out.shape[dimB_out], strideB):
        
        # compute batch index in the input tensor in a cyclic fashion
        b_in = b_out % batch_in.shape[dimB_in]
        
        {% for op, param, params in spatial_ops: %}
        {% if op.has_params(): %}
        {{param}} = {{params}}[b_out] # {{op.inline.__doc__}}
        {% endif %}
        {% endfor %}
        
        {% for op, param, params in color_ops: %}
        {% if op.has_params(): %}
        {{param}} = {{params}}[b_out] # {{op.inline.__doc__}}
        {% endif %}
        {% endfor %}
        
        {% if dim > 0: %}
        # for all x coordinates in the output tensor
        for x_out in range(lowerX, batch_out.shape[dimX_out], strideX):            
        {% endif %}
            {% if dim > 1: %}
            # for all y coordinates in the output tensor
            for y_out in range(lowerY, batch_out.shape[dimY_out], strideY):
            {% endif %}
                {% if dim > 2: %}
                # for all z coordinates in the output tensor
                for z_out in range(lowerZ, batch_out.shape[dimZ_out], strideZ):
                {% endif %}
                    {% if dim > 3: %}
                    # for all t coordinates in the output tensor
                    for t_out in range(lowerT, batch_out.shape[dimT_out], strideT):
                    {% endif %}
                
                        # map output dimensions into cube [0, 1]^{{dim}}
                        {% if dim > 0: %}
                        x = x_out/(batch_out.shape[dimX_out]-1.0)
                        {% endif %}
                        {% if dim > 1: %}
                        y = y_out/(batch_out.shape[dimY_out]-1.0)
                        {% endif %}
                        {% if dim > 2: %}
                        z = z_out/(batch_out.shape[dimZ_out]-1.0)
                        {% endif %}
                        {% if dim > 3: %}
                        t = t_out/(batch_out.shape[dimT_out]-1.0)
                        {% endif %}

                        #############################################
                        # spatial transformations start here
                        #############################################
                        
                        {% for op, param, params in spatial_ops: %}
                        # {{op.inline.__doc__}}
                        {% for line in op.inline()%}
                        {{line.format(param=param)}} 
                        {% endfor %}
                        
                        {% endfor %}
                        #############################################
                        # spatial transformations stop here
                        #############################################
                                        
                        # check if after mapping still in the cube [0, 1]^{{dim}}
                        {% if dim > 0: %}
                        x_inside = 0.0 <= x <= 1.0
                        {% endif %}
                        {% if dim > 1: %}
                        y_inside = 0.0 <= y <= 1.0
                        {% endif %}
                        {% if dim > 2: %}
                        z_inside = 0.0 <= z <= 1.0
                        {% endif %}
                        {% if dim > 3: %}
                        t_inside = 0.0 <= t <= 1.0
                        {% endif %}

                        # if coordinates refer to valid regions in the input tensor
                        {% if dim == 1 %}
                        if x_inside:
                        {% endif %}
                        {% if dim == 2 %}
                        if x_inside and y_inside:
                        {% endif %}
                        {% if dim == 3 %}
                        if x_inside and y_inside and z_inside:
                        {% endif %}
                        {% if dim == 4 %}
                        if x_inside and y_inside and z_inside and t_inside:
                        {% endif %}
                    
                            # mapping cube [0, 1]^{{dim}} onto dimensions of input tensor
                            {% if dim > 0: %}
                            x_in = x*(batch_in.shape[dimX_in]-1.0)
                            {% endif %}
                            {% if dim > 1: %}
                            y_in = y*(batch_in.shape[dimY_in]-1.0)
                            {% endif %}
                            {% if dim > 2: %}
                            z_in = z*(batch_in.shape[dimZ_in]-1.0) 
                            {% endif %}
                            {% if dim > 3: %}
                            t_in = t*(batch_in.shape[dimT_in]-1.0) 
                            {% endif %}
           
                            # nearest neighbor interpolation for each of the {{dim}} dimensions
                            {% if dim > 0: %}
                            x_in = int(round(x_in))
                            {% endif %}
                            {% if dim > 1: %}
                            y_in = int(round(y_in))
                            {% endif %}
                            {% if dim > 2: %}
                            z_in = int(round(z_in))
                            {% endif %}
                            {% if dim > 3: %}
                            t_in = int(round(t_in))
                            {% endif %}
                            
                            for c in range(lowerC, batch_in.shape[dimC_in], strideC):
                                
                                {% if channel_mode == 'CF2CF' or channel_mode == 'CF2CL': %}
                                {% if dim == 1: %}
                                v = batch_in[b_in, c, x_in]
                                {% endif %}
                                {% if dim == 2: %}
                                v = batch_in[b_in, c, x_in, y_in]
                                {% endif %}
                                {% if dim == 3: %}
                                v = batch_in[b_in, c, x_in, y_in, z_in]
                                {% endif %}
                                {% if dim == 4: %}
                                v = batch_in[b_in, c, x_in, y_in, z_in, t_in]
                                {% endif %}
                                {% endif %}
                                {% if channel_mode == 'CL2CF' or channel_mode == 'CL2CL': %}
                                {% if dim == 1: %}
                                v = batch_in[b_in, x_in, c]
                                {% endif %}
                                {% if dim == 2: %}
                                v = batch_in[b_in, x_in, y_in, c]
                                {% endif %}
                                {% if dim == 3: %}
                                v = batch_in[b_in, x_in, y_in, z_in, c]
                                {% endif %}
                                {% if dim == 4: %}
                                v = batch_in[b_in, x_in, y_in, z_in, t_in, c]
                                {% endif %}
                                {% endif %}
                                
                                #############################################
                                # color transformations start here
                                #############################################
                        
                                {% for op, param, params in color_ops: %}
                                # {{op.inline.__doc__}}
                                {% for line in op.inline()%}
                                {{line.format(param=param)}} 
                                {% endfor %}
                        
                                {% endfor %}
                                #############################################
                                # color transformations stop here
                                #############################################
                                
                                {% if channel_mode == 'CF2CF' or channel_mode == 'CL2CF': %}
                                {% if dim == 1: %}
                                batch_out[b_out, c, x_out] = v
                                {% endif %}
                                {% if dim == 2: %}
                                batch_out[b_out, c, x_out, y_out] = v
                                {% endif %}
                                {% if dim == 3: %}
                                batch_out[b_out, c, x_out, y_out, z_out] = v
                                {% endif %}
                                {% if dim == 4: %}
                                batch_out[b_out, c, x_out, y_out, z_out, t_out] = v
                                {% endif %}
                                {% endif %}
                                {% if channel_mode == 'CL2CL' or channel_mode == 'CF2CL': %}
                                {% if dim == 1: %}
                                batch_out[b_out, x_out, c] = v
                                {% endif %}
                                {% if dim == 2: %}
                                batch_out[b_out, x_out, y_out, c] = v
                                {% endif %}
                                {% if dim == 3: %}
                                batch_out[b_out, x_out, y_out, z_out, c] = v
                                {% endif %}
                                {% if dim == 4: %}
                                batch_out[b_out, x_out, y_out, z_out, t_out, c] = v
                                {% endif %}
                                {% endif %}
                                
                        # else fill in empty values definied per color channel
                        else:
                            for c in range(lowerC, batch_in.shape[dimC_in], strideC):
                                {% if channel_mode == 'CF2CF' or channel_mode == 'CL2CF': %}
                                {% if dim == 1: %}
                                batch_out[b_out, c, x_out] = empty_values[c]
                                {% endif %}
                                {% if dim == 2: %}
                                batch_out[b_out, c, x_out, y_out] = empty_values[c]
                                {% endif %}
                                {% if dim == 3: %}
                                batch_out[b_out, c, x_out, y_out, z_out] = empty_values[c]
                                {% endif %}
                                {% if dim == 4: %}
                                batch_out[b_out, c, x_out, y_out, z_out, t_out] = empty_values[c]
                                {% endif %}
                                {% endif %}
                                {% if channel_mode == 'CL2CL' or channel_mode == 'CF2CL': %}
                                {% if dim == 1: %}
                                batch_out[b_out, x_out, c] = empty_values[c]
                                {% endif %}
                                {% if dim == 2: %}
                                batch_out[b_out, x_out, y_out, c] = empty_values[c]
                                {% endif %}
                                {% if dim == 3: %}
                                batch_out[b_out, x_out, y_out, z_out, c] = empty_values[c]
                                {% endif %}
                                {% if dim == 4: %}
                                batch_out[b_out, x_out, y_out, z_out, t_out, c] = empty_values[c]
                                {% endif %}
                                {% endif %}

'''